{
    "contents" : "\n\n#function that takes a position and converts it to two vectors, one with X coordinate and one with Y coordinate)\n\nPosToCord <- function(positionvector, row){\n  remainX <- positionvector %% row \n  log <- remainX %in% 0 \n  remainX[log] <- row\n  \n  remainY <- ceiling(positionvector/row)\n  XY <- cbind(remainX, remainY)\n  colnames(XY) <- c('X',\"Y\")\n  return(XY)\n}\n\n#create an image of our current position matrix\n#now we have positions and corresponding cordinates for red and blue \n#we implement our matrix below by assigning 1 to red and 2 to blue\n#we also alter our matrix because the image function takes in the matrix differently\n\n\nimagematrix <- function(redposition, blueposition, r, c){\n  \n  grid <- matrix(0, nrow=r, ncol=c)\n  grid[redposition] <- 1\n  grid[blueposition] <- 2\n  \n  AltGrid <- t(grid[r:1,])\n  image(AltGrid, col =c(\"white\",\"red\",\"blue\"))\n}\n\nMoveCord <- function(redcord, bluecord, time, row, column){\n  if (time %% 2 != 0 ){\n    bluecordORIG <- bluecord \n    bluecord1 <- bluecord[,\"X\"] - 1\n    logical <- bluecord1 %in% 0\n    bluecord1[logical] <- row\n    bluecord[,\"X\"] <- bluecord1\n    fullmat <- rbind(bluecordORIG, redcord, bluecord)\n    logical1 <- duplicated(fullmat)\n    fullrow <- nrow(bluecordORIG) + nrow(redcord)\n    shortlogical <- logical1[-(1:fullrow)]\n    if (any(shortlogical)){\n      update <- bluecord[!shortlogical,]\n      bluecordORIG[!shortlogical,] <- update\n      bluecord <- bluecordORIG\n    }\n    \n    return(list(redcord, bluecord))\n    #blueINred <- apply(bluecord, 1, function(x) x[1] == redcord[,1] & x[2] == redcord[,2])\n    #whichInred <- apply(blueINred, 2, any)\n    #if(any(whichInred)){\n     #replace <- bluecordORIG[whichInred]\n      #bluecord[whichInred] <- replace \n    #}\n    #making sure there are no repeating, when one eats the other \n    #dup <- as.list(data.frame(t(bluecord[duplicated(bluecord),])))\n    #bluelist <- as.list(data.frame(t(bluecord)))\n    #logicaldup <- bluelist %in% dup \n    #if(any(logicaldup)){\n      #bluecord[logicaldup,] <- bluecordORIG[logicaldup,]\n    #}\n    \n  }\n  \n  if (time %% 2 == 0){\n    redcordORIG <- redcord \n    redcord1 <- redcord[, \"Y\"] + 1\n    logical11 <- redcord1 %in% (column+1)\n    redcord1[logical11] <- 1 \n    redcord[,\"Y\"] <- redcord1\n    fullmat1 <- rbind(redcordORIG, bluecord, redcord)\n    logical2 <- duplicated(fullmat1)\n    fullrow1 <- nrow(redcordORIG) + nrow(bluecord)\n    shortlogical1 <- logical2[-(1:fullrow1)]\n    if (any(shortlogical1)){\n      update1 <- redcord[!shortlogical1,]\n      redcordORIG[!shortlogical1,] <- update1\n      redcord <- redcordORIG\n    }\n    return(list(redcord, bluecord))\n    #redINblue <- apply(redcord, 1, function(x) x[1] == bluecord[,1] & x[2] == bluecord[,2])\n    #whichInblue <- apply(redINblue, 2, any)\n    #if(any(whichInblue)){\n    #  replace1 <- redcordORIG[whichInblue]\n    #  redcord[whichInblue] <- replace1 \n    #}\n    \n    #making sure there are no repeats when one eats the other \n    #dup1 <- as.list(data.frame(t(redcord[duplicated(redcord),])))\n    #redlist <- as.list(data.frame(t(redcord)))\n    #logicaldup1 <- redlist %in% dup1\n    #if(any(logicaldup1)){\n    #  redcord[logicaldup1,] <- redcordORIG[logicaldup1,]\n    #}\n  }   \n}\n\n\n########\n\n\ncordToPos <- function(REDCORD,BLUECORD, row){\n  newRedpos <- REDCORD[,\"X\"] + ((REDCORD[,\"Y\"] -1)*row)\n  newBluepos <- BLUECORD[, \"X\"] + ((BLUECORD[,\"Y\"] -1)*row)\n  retrurn(list(newRedpos,newBluepos))\n}\n\n\ncreateBMLGrid<- function(r=3, c=3, ncars = c(red=2,blue=2)){\n  \n  if (ncars[1]+ncars[2] > r*c){\n    stop(\"Too many cars were selected!\")\n  }\n  \n  #creating a vector of positions based on total length of grid and then sample randomly\n  #by total number of cars\n  totallength <- r*c \n  totalcars <- ncars[1]+ncars[2]\n  OrdPos <- c(1:(totallength))\n  #randomly sample but do not repeat\n  Pos <- sample(OrdPos, totalcars, replace=FALSE)\n  #assign random positions to car color\n  redPos <- Pos[1:ncars[1]]\n  bluePos <- Pos[(ncars[1]+1):totalcars] \n  \n  #get the image of our position \n  \n  imagematrix(redPos,bluePos, r, c)\n  \n  #set our positions\n  positions<- list(redPos,bluePos)\n  return(list(positions = positions, r = r, c = c))\n}\n\n\nplot.BMLgrid <- function(x, ...){\n  finalposition <- x[[1]]\n  r <- x[[2]]\n  c <- x[[3]]\n  sapply(finalposition, function(x) imagematrix(x[[1]],x[[2]], r, c))\n}\n\n\nrunBMLGrid <- function(positionG, totaltime=5) {\n  r <- positionG[[2]]\n  c <- positionG[[3]]\n  positions <- positionG[[1]]\n  posfinal <- list(positions)\n  \n  for (time in 1:totaltime){\n    redCord <- PosToCord(positions[[1]],r)\n    blueCord <- PosToCord(positions[[2]],r)\n    newcords <- MoveCord(redCord,blueCord, time, r, c)\n    positions <- cordToPos(newcords[[1]], newcords[[2]],r)\n    posfinal <- append(posfinal, list(positions))\n    #imagematrix(positions[[1]],positions[[2]], r, c)\n  }\n  yy <- list(posfinal, r, c)\n # class(yy) <- 'imatrix'\n  class(yy) <- c(\"BMLgrid\", class(yy))\n  yy\n}\n\nmoved <- function(out, period){\n  positions <- out[[1]]\n  redmoved <- positions[[period +1]][[1]] - positions[[period]][[1]]\n  bluemoved <- positions[[period +1]][[2]] - positions[[period]][[2]]\n  allmove <- append(redmoved,bluemoved)\n  carsmoved <- length(allmove[allmove!=0])\n  return(carsmoved)\n}\n\nblocked <- function(output, period){\n  positions <- output[[1]]\n  if (period %% 2 != 0){\n    shift <- positions[[period+1]][[2]] - positions[[period]][[2]]\n    shift1 <- shift[shift==0] \n    block <- length(shift1)\n  }\n  if (period %% 2 == 0){\n    shift <- positions[[period+1]][[1]] - positions[[period]][[1]]\n    shift1 <- shift[shift==0] \n    block <- length(shift1)\n  }\n  return(block)\n}\n\n\nvelocity <- function(out, period, redcar, bluecar){\n  positions <- out[[1]]\n  redmoved <- positions[[period +1]][[1]] - positions[[period]][[1]]\n  bluemoved <- positions[[period +1]][[2]] - positions[[period]][[2]]\n  allmove <- append(redmoved,bluemoved)\n  carsmoved <- length(allmove[allmove!=0])\n  if (period %% 2!= 0){\n    velocity <- carsmoved/bluecar\n  }\n  if (period %% 2==0){\n    velocity <- carsmoved/redcar\n  }\n  return(velocity)\n}\n\n\nsummary.BMLgrid <- function(Gout,...){\n  lastpos <- Gout[[1]]\n  lastnum <- length(lastpos)\n  finalgrid <- lastpos[[lastnum]]\n  redcar <- length(finalgrid[[1]])\n  bluecar <- length(finalgrid[[2]])\n  velocity <- velocity(Gout, lastnum-1, redcar, bluecar)\n  gridsize <- c(Gout[[2]], Gout[[3]])\n  text1 <- cat(\" The number of red cars is/are\", redcar, \".\\n\")\n  text2 <- cat(\" The number of blue cars is/are\", bluecar, \".\\n\")\n  text3 <- cat(\" The grid size is\", gridsize, \".\\n\")\n  text4 <- cat(\" The velocity in the last position is\", velocity, \".\\n\")\n}\n\n\n#here is where I optimize the function\n#make sure to print this output\nRprof()\n###run function \nRprof(NULL)\nsummaryRprof()\n  \n#I adjust these parameters multiple times when running my code but below is just a test\n#Here is an example where I actually end up making multiple GIFS by changing outputs\nlibrary(animation)\npositiongrid <- createBMLGrid(31, 31, ncars=c(400,400))\ng.out = runBMLGrid(positiongrid, 100)\nplot(g.out)\nsummary(g.out)\nsaveGIF(plot(g.out), movie.name = 'mygif.gif', interval=0.2)\nmoved(g.out,5)\nblocked(g.out,5)\nvelocity(g.out,200,1750,1750)\n\n#blocks by proportion I just went through this function and changed the parameters to get the averages\npositiongrid <- createBMLGrid(31,31, ncars=c(450,50))\ng.out = runBMLGrid(positiongrid, 100)\n\nblock <- rep(0,100)\nfor (i in 1:100){\n  block[i] <- blocked(g.out,i)\n}\n\navg1 <- mean(block) # at .10 #117\navg2 <- mean(block) # at .20 #144\navg3 <- mean(block) # at .50 #166\navg4 <- mean(block) # at .80 #139\navg5 <- mean(block) # at .90 #104\n\nprop <- c(avg1,avg2,avg3,avg4,avg5)\nxcord <- c(.10, .20, .50, .80, .90)\n\nplot(xcord, prop, type=\"b\", xlab=\"prop of reds\", ylab=\"average number blocked\", main=\"AVG Block based on color proportions over 100 steps\")\n\n\n#iterating velocity over time for specific cases \npar(mfrow = c(2, 1))\npositiongrid <- createBMLGrid(5, 5, ncars=c(10,10))\ng.out = runBMLGrid(positiongrid, )\n\nveloc <- rep(0,100)\n\nfor (i in 1:100){\n  veloc[i] <-velocity(g.out,i, 300, 300)\n}\n\nplot(veloc,type=\"b\", xlab=\"time\", main=\"Velocity over time for 1000 grid with 400 R and 200 B\")\n\npositiongrid <- createBMLGrid(100, 100, ncars=c(4000,2000))\ng.out = runBMLGrid(positiongrid, 100)\nveloc <- rep(0,100)\n\nfor (i in 1:100){\n  veloc[i] <-velocity(g.out,i, 3000, 3000)\n}\n\n\nplot(veloc, type=\"b\", xlab=\"time\", main=\"Velocity over time for 10000 grid with 4000 R and 2000 B\")\n\n\n\n#timing \n\nRprof()\nrunBMLGrid(positiongrid, 100)\nRprof(NULL)\nsummaryRprof()\nsystem.time(runBMLGrid(positiongrid, 500))\n\n#100 , 35 35, 0.68 seconds \n#1000 5.471\n#5000 32.358 \n#100000 35 35, 63 seconds \n\n#I plug in various grid values into my function from above and return these vectors then I plot\n\nx <- c(100, 1000, 5000, 10000)\ny <- c(0.68, 5.471, 32.358, 63)\n\nplot(x,y, type='b', xlab=\"gridsize\", ylab=\"time\", main=\"Time it takes to process function\")\n\n\n\n#packages \nman/ <- docs  #package documentation check out github.com/nick-ulle/2013-mlexamples\nR/ <- R code\ntests/ <- tests \nDESCRITPION <- description #think that pops up on the side NO FILE TYPE \nNAMESPACE <- export function  #functions that i want to use like run bml \n            S3\n\ntouch to create \nvim is to text edit the file\n\n#last two are files \n\n# you have to run R CMD check. \n\n#writing R extensions\n\nR CMD INSTALL. \n\n\n#print out velocity of last step, average velocity from the beginning number of cars, grid, number of cars that will bea ble to move on the next step \n#few things of interest\n\npackage.skeleton()\n\n\n\n\n\nlibrary(BMLflows)\n\n\n####\n\nuseDynLib(BMLflows)\n",
    "created" : 1430317446817.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3281055886",
    "id" : "FC5199F4",
    "lastKnownWriteTime" : 1430930305,
    "path" : "~/Desktop/School/STA242/Assign2_242_hw2.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}